
####################################################
## Function to re-estimate the Gamma Distribution ##
## parameters of the Emission Distribution        ##
####################################################

mstep.gamma <- function(x, wt = NULL){
  tmp <- apply(wt, 2, function(w) weighted.params(x, w))
  return(list(shape = tmp[1, ], scale = tmp[2, ]))
}

weighted.params <- function(x, wt){
  tmp1 <- weighted.mean(x, wt, na.rm = TRUE)
  sum <- 0
  for(i in 1:length(x)){
    sum <- sum + wt[i] * (ifelse(is.na(x[i]), tmp1, x[i]) - tmp1) ^ 2
  }
  wt_notNulls <- wt[!(1:length(wt)) %in% which(is.na(x))]
  tmp2 <- sum / sum(wt_notNulls)
  scale <- tmp2 / tmp1
  shape <- tmp1 / scale
  return(c(shape, scale))
}


###############################################
## Function to generate 1 Gamma Distribution ##
## Random Value for State j                  ##
###############################################

rgamma.hsmm <- function(j, model){
  rgamma(n = 1, shape = model$parms.emission$shape[j], scale = model$parms.emission$scale[j])
}


######################################################
## Function to generate corresponding Gamma Density ##
## values for a vector of quantiles for State j     ##
######################################################

dgamma.hsmm <- function(x, j, model){
  ret <- dgamma(x = x, shape = model$parms.emission$shape[j], scale = model$parms.emission$scale[j])
  # Replacing NAs by 1 (similar to the mhsmm package)
  ret[is.na(ret)] <- 1
  ret
}


#############################################################################
## Function to estimate the time already spent in the last state of the    ##
## state sequence generated by the in-built mhsmm package predict function ##
#############################################################################

time_in_state <- function(pred_list){
  last_predicted_state <- pred_list[length(pred_list)]
  count <- 1
  for(i in 1:length(pred_list)){
    if(last_predicted_state == pred_list[length(pred_list) - i]){
      count <- count + 1
    }
    else{
      return(count)
    }
  }
  return(count)
}


#########################
## Prediction Function ##
#########################

predict_new <- function(model, observed_CGM_list, predict_at = 60){
  pred_from_hsmm <- predict(model, observed_CGM_list)$s
  
  # last predicted state using the in-built predict function for the observed 
  # CGM time-series
  last_state <- pred_from_hsmm[length(pred_from_hsmm)]
  original_state <- last_state # A copy of the last state to keep a record of the 
  # starting point for each iteration of the Monte Carlo simulation.
  
  # Calculate the time the system has already spent in the last state according 
  # to the in-built predict function using the observed CGM time-series
  tau <- time_in_state(pred_from_hsmm)
  
  # The next statement and the loop create a matrix to contain the cumulative values of
  # the density distribution values generated by the trained model.
  cumsum_d <- matrix(integer(length(model$model$sojourn$d)), nrow = length(model$model$sojourn$d) / 5, byrow = TRUE)
  for(i in 1:5){
    cumsum_d[,i] <- cumsum(model$model$sojourn$d[,i])
  }
  
  # Generate 10000 random uniform distribution values using using last state, 
  # and cumulative values of the sojourn density distribution.
  # tau (time already spent in the current state) helps to assign the minimum parameter for runif.
  # For maximum parameter of runif, we use the maximum value in cumsum_d for the last state.
  # This gives us runif values that are strictly greater than or equal to the time the system
  # has already spent in the current state.
  runif_vals <- runif(n = 10000, min = cumsum_d[tau,last_state] , max = max(cumsum_d[,last_state]))
  
  # Matrix to store records of state predictions
  state_predictions <- matrix(integer(10000 * predict_at / 5), nrow = 10000, byrow = TRUE)
  # Matrix to store all runif values for current and future transitions (Only for keeping records)
  runif_records <- matrix(integer(10000 * predict_at / 5), nrow = 10000, byrow = TRUE)
  # Matrix to store values showing how much time needs to be spent in the current state (Only for keeping records)
  time_matrix <- matrix(integer(10000 * predict_at / 5), nrow = 10000, byrow = TRUE)
  
  for(i in 1:10000){ # 10000 iterations of the Monte Carlo simulation
    # Saving a record of the runif value at the beginning of each iteration of the Monte Carlo simulation
    runif_records[i,1] <- runif_vals[i]
    FCV <- 1 # Indicates time point (Varies from 1 to 12)
    flag <- 0 # Flag variable: To indicate when a transition is required
    
    # If there is an exact match between the runif value and any value of cumsum_d for the last state column
    # then (cumsum_d[, last_state]==runif_vals[i]) will return 1 TRUE and 143 FALSE values. 
    if(length(unique(cumsum_d[, last_state]==runif_vals[i]))==2){
      # which(cumsum_d[, last_state]==runif_vals[i]) gives us how much time the system should spent 
      # in the last state and tau gives us how much time the system has already spent in the last state.
      # Hence, the difference gives us how many additional timepoints the system is expected to spent in
      # the last state.
      time <- which(cumsum_d[, last_state]==runif_vals[i]) - tau
      time_matrix[i,1] <- time # Saving a record of how many timepoints the system is
      # expected to spent in the last state at the beginning of each iteration of the Monte Carlo simulation.
    }
    else{
      # If cumsum_d and runif do not have an exact match then we find the index of the
      # minimum value in cumsum_d that is greater than the value stored in runif_vals and
      # subtract (1 + tau) from it.
      time <- which.max(cumsum_d[, last_state] > runif_vals[i]) - 1 - tau
      time_matrix[i,1] <- time # Saving a record of how many timepoints the system is
      # expected to spent in the last state at the beginning of each iteration of the Monte Carlo simulation.
    }
    
    # If time is less than or equal to zero, it means that no more timepoints will
    # be spent in the last state and a transition will take place.
    if(time <= 0){
      flag <- 1
    }
    else{

    }
    repeat{
      if(flag==1){ # flag variable is 1 when time is less than or equal to 0
        # Find how many time points the system needs to spend in the new state
        time <- which.max(cumsum_d[, last_state] > runif(n = 1, min = 0 , max = max(cumsum_d[, last_state]))) - 1
        time_matrix[i,FCV] <- time # Saving a record of how many time points the 
        # system is expected to spent in the new state at the point of transition 
        
        if(time < 1){ # If the drawn time is less than 1 then we cannot have another transition
          # using the current state as our system does not skip states. Hence, the system
          # goes back to the previous state, then we have a transition and draw time values
          
          if(FCV != 1){ # If time is less than 1 at the beginning of the simulation then the 
            # value in the variable last_state is unchanged (that is, it is the original_value)
            # and we can proceed ahead towards determining the transition.
            last_state <- state_predictions[i,FCV-1]
          }
        }
        
      }
      
      # The while loop below has two conditions: time < 1 indicates a transition is required.
      # FCV is the counter for time points, hence the simulation process is terminated
      # once the FCV value reaches floor(predict_at/5)
      while(time >= 1 & FCV <= floor(predict_at/5)){
        state_predictions[i,FCV] <- last_state # Saving a record of the state prediction
        FCV <- FCV + 1 # Incrementing the time points counter by 1
        time <- time - 1 # Decrementing the time to be spent in the current state by 1
      }
      
      # The repeat loop is terminated once the FCV (counter for timepoints) becomes 
      # greater than floor(predict_at/5)
      if(FCV == floor(predict_at/5)+1){
        last_state <- original_state # Assigning the final state predicted by the in-built
        # predict function for the observed CGM time-series. This will be the beginning point
        # of the next iteration of the Monte Carlo simulations.
        break
      }
      
      flag <- 1 # Assign 1 to the flag variable which indicates a transition. Here, we need
      # a transition as the above if statement did not break the repeat block which indicates 
      # that FCV hasn't exceeded its maximum value of floor(predict_at/5) and the while loop
      # was terminated which indicates that the time to be spent in the current state has 
      # gone below 1.
      if(last_state == 1){ # If the current state is 1 then in this system the next
        # state after a transition has to be 2
        last_state <- 2
      }
      else if(last_state == 5){ # If the current state is 5 then in this system the next
        # state after a transition has to be 4
        last_state <- 4
      }
      
      # Explanation for the next else block: if the current state is 2 then the possible
      # transitions are 2 to 1 and 2 to 3, similarly, if the current state is 3 then the 
      # possible transitions are 3 to 2 and 3 to 4 and if the current state is 4 then the
      # possible transitions are 4 to 3 and 4 to 5. To determine the transition, we draw
      # a random value from a (0, 1) uniform distribution and compare it with the values
      # in the transition matrix of the trained model.
      # Suppose the current state is 3 then we will first determine from the transition
      # matrix which out of the transitions (3 to 2 or 3 to 4) has a lower value (say 3 to 2).
      # If the uniform distribution draw is less than or equal to the lower value from
      # the transition matrix then we choose that transition (3 to 2 as per this example) else we 
      # choose the transition in the opposite direction (3 to 4 as per this example).
      # In the scenario, where both 3 to 2 and 3 to 4 have a 50% probability then if the 
      # uniform distribution draw is less than or equal to 0.5 then we choose the transition
      # towards a lower glycemic state (3 to 2 as per this example) else we choose the transition 
      # towards a higher glycemic state (3 to 4 as per this example).
      else{
        new_runif <- runif(1,0,1)
        transit_prob <- new_runif
        runif_records[i, FCV] <- new_runif
        if(model$model$transition[last_state,last_state-1] <= model$model$transition[last_state,last_state+1]){
          if(transit_prob <= model$model$transition[last_state,last_state-1]){
            last_state <- last_state - 1
          }
          else{
            last_state <- last_state + 1
          }
        }
        else{
          if(transit_prob <= model$model$transition[last_state,last_state+1]){
            last_state <- last_state + 1
          }
          else{
            last_state <- last_state - 1
          }
        }
      }
    } # Exit: the repeat block
  } # Exit: the for loop (i in 1:10000)
  

  # Using the 10000 Monte Carlo simulations the following for loop calculates how many
  # times each state was seen at each time point and reports the corresponding fraction.
  # The size of the matrix fraction_of_state is 5 x 12 (assuming predict_at = 60) and 
  # each column of the matrix sums to 1. The rows of the matrix represents states from 1 to 5
  # and columns of the matrix represent time points 1 to 12 (assuming predict_at = 60).
  fraction_of_state <- matrix(integer(predict_at), nrow = 5, byrow = TRUE)
  for(i in 1:(predict_at/5)){
    pred_count <- table(state_predictions[,i])
    m <- 1
    for(j in 1:5){
      pred_count_header_str <- names(pred_count)
      pred_count_header_int <- strtoi(pred_count_header_str)
      if(m > length(pred_count_header_int)){
        
      }
      else{
        if(j == pred_count_header_int[m]){
          fraction_of_state[j,i] <- pred_count[pred_count_header_str[m]]
          m <- m + 1
        }
        else{
          fraction_of_state[j,i] <- 0
        }
      }
    }
    fraction_of_state[,i] <- fraction_of_state[,i] / length(state_predictions[,i])
  }
  
  
  prob_of_state <- matrix(integer(15), nrow = 3, byrow = TRUE)
  # row 1 gives probability of hypoglycemia for each state.
  # row 2 gives probability of normal range for each state.
  # row 3 gives probability of hyperglycemia for each state.
  prob_of_state[1,] <- sapply(1:5, function(i) pgamma(70, shape = model$model$parms.emission$shape[i], scale = model$model$parms.emission$scale[i]))
  prob_of_state[3,] <- sapply(1:5, function(i) 1 - pgamma(180, shape = model$model$parms.emission$shape[i], scale = model$model$parms.emission$scale[i]))
  prob_of_state[2,] <- sapply(1:5, function(i) 1 - prob_of_state[3,i] - prob_of_state[1,i])


  # row 1 gives probability of hypoglycemia for each time point.
  # row 2 gives probability of normal range for each time point.
  # row 3 gives probability of hyperglycemia for each time point.
  # prob_of_state is a 3 x 5 matrix whereas fraction_of_state is a 5 x 12 matrix (assuming predict_at = 60).
  # The multiplication gives us a 3 x 12 matrix (assuming predict_at = 60) where row 1 represents hypoglycemic event,
  # row 2 represents normal glycemic range, and row 3 represents hyperglycemic event and the columns represent 12 timepoints.
  # This multiplication gives us the probability of each event at each timepoint.
  prob_at_time_points <- prob_of_state %*% fraction_of_state
  
  # The code below helps us to develop a 10000 x 12 matrix (assuming predict_at = 60) which
  # contains emission distribution values which are determined using the trained model 
  # emission distribution parameters, the in-built rgamma function, and the state_predictions
  # matrix which was developed above using Monte Carlo simulations. The emis_prediction matrix is
  # further used to determine the probability of an hypoglycemic event within the next 30 minutes
  # and the probability of hypoglycemic event within the next 60 minutes.
  # Note: No threshold of 0.05 or any other threshold is applied to calculate these probabilities.
  emis_prediction <- matrix(integer(10000 * predict_at / 5), nrow = 10000, byrow = TRUE)
  for(i in 1:nrow(state_predictions)){
    for(j in 1:ncol(state_predictions)){
      emis_prediction[i,j] <- rgamma(
        n = 1,
        shape = model$model$parms.emission$shape[state_predictions[i,j]],
        scale = model$model$parms.emission$scale[state_predictions[i,j]]
      )
    }
  }

  # Find the probability of a hypoglycemic event within the next 30 minutes
  Prob_of_Hypo_30min <- append(sapply(1:7, function(j) {
    sum(sapply(1:nrow(emis_prediction), function(i)
      any(emis_prediction[i, j:(j+5)] < 70))) / nrow(state_predictions)
  }), rep(NA, 5))
  
  # Find the probability of a hypoglycemic event within the next 60 minutes
  Prob_of_Hypo_60min <- append(sum(sapply(1:nrow(emis_prediction), function(i) 
    any(emis_prediction[i, ] < 70))) / dim(state_predictions)[1], rep(NA, 11))

  
  list_to_return <- list(
    pred_from_hsmm[length(pred_from_hsmm)],
    state_predictions,
    fraction_of_state,
    prob_of_state,
    prob_at_time_points,
    time_matrix,
    Prob_of_Hypo_30min,
    Prob_of_Hypo_60min,
    emis_prediction
  )
  
  return(list_to_return)
}